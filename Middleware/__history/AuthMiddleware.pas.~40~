unit AuthMiddleware;

interface

uses
  Horse,
  Horse.Core.RouterTree,
  Horse.Core.Route,
  Horse.Request,
  Horse.Response,
  Horse.Commons,
  Web.HTTPApp,
  System.SysUtils,
  System.JSON,
  System.Classes,
  System.Generics.Collections,
  Data.DB,
  JWTManager,
  UserModel;

type
  TAuthMiddleware = class
  private
    class function ExtractBearerToken(const AuthHeader: string): string;
    class function ValidateAndExtractClaims(const AToken: string; out Claims: TJWTClaims): Boolean;
    class function IsValidRole(const UserRole: TUserRole): Boolean;
    class procedure StoreClaimsInRequest(Req: THorseRequest; const Claims: TJWTClaims);
    class function IsPublicPath(const Path: string): Boolean;
  public
    class function Middleware: THorseCallback;
  end;

implementation

{ TAuthMiddleware }

class function TAuthMiddleware.ExtractBearerToken(const AuthHeader: string): string;
begin
  Result := '';
  if AuthHeader.StartsWith('Bearer ', True) then
    Result := AuthHeader.Substring(7);
end;

class function TAuthMiddleware.ValidateAndExtractClaims(const AToken: string; out Claims: TJWTClaims): Boolean;
begin
  Result := False;
  try
    Result := TJWTManager.ValidateToken(AToken, Claims);
  except
    on E: Exception do
      Result := False;
  end;
end;

class function TAuthMiddleware.IsValidRole(const UserRole: TUserRole): Boolean;
begin
  // Check if user has either Admin or StockOfficer role
  Result := (UserRole = urAdmin) or (UserRole = urStockOfficer);
end;

class procedure TAuthMiddleware.StoreClaimsInRequest(Req: THorseRequest; const Claims: TJWTClaims);
begin
  Req.Query.Dictionary.AddOrSetValue('user-id', Claims.UserId.ToString);
  Req.Query.Dictionary.AddOrSetValue('user-role', IntToStr(Integer(Claims.Role)));
  Req.Query.Dictionary.AddOrSetValue('username', Claims.Username);
end;

class function TAuthMiddleware.IsPublicPath(const Path: string): Boolean;
begin
  Result := (Path = '/auth/login') or (Path = '/auth/register');
end;

class function TAuthMiddleware.Middleware: THorseCallback;
begin
  Result := procedure(Req: THorseRequest; Res: THorseResponse; Next: TProc)
    var
      AuthHeader: string;
      Token: string;
      Path: string;
      Claims: TJWTClaims;
      ErrorObj: TJSONObject;
    begin
      try
        // Get the current path
        Path := Req.RawWebRequest.PathInfo.ToLower;

        // Skip authentication for public endpoints
        if IsPublicPath(Path) then
        begin
          Next;
          Exit;
        end;

        // Get Authorization header
        AuthHeader := Req.Headers['Authorization'];
        if AuthHeader.IsEmpty then
        begin
          ErrorObj := TJSONObject.Create;
          try
            ErrorObj.AddPair('error', 'Authorization header is required');
            Res.Status(401).Send<TJSONObject>(ErrorObj);
          except
            ErrorObj.Free;
            raise;
          end;
          Exit;
        end;

        // Extract token
        Token := ExtractBearerToken(AuthHeader);
        if Token.IsEmpty then
        begin
          ErrorObj := TJSONObject.Create;
          try
            ErrorObj.AddPair('error', 'Invalid authorization format');
            Res.Status(401).Send<TJSONObject>(ErrorObj);
          except
            ErrorObj.Free;
            raise;
          end;
          Exit;
        end;

        // Validate token and extract claims
        if not ValidateAndExtractClaims(Token, Claims) then
        begin
          ErrorObj := TJSONObject.Create;
          try
            ErrorObj.AddPair('error', 'Invalid or expired token');
            Res.Status(401).Send<TJSONObject>(ErrorObj);
          except
            ErrorObj.Free;
            raise;
          end;
          Exit;
        end;

        // Check if user has valid role (Admin or StockOfficer)
        if not IsValidRole(Claims.Role) then
        begin
          ErrorObj := TJSONObject.Create;
          try
            ErrorObj.AddPair('error', 'Insufficient permissions. Only Admin and Stock Officers are allowed.');
            Res.Status(403).Send<TJSONObject>(ErrorObj);
          except
            ErrorObj.Free;
            raise;
          end;
          Exit;
        end;

        // Store claims in request
        StoreClaimsInRequest(Req, Claims);

        Next;
      except
        on E: Exception do
        begin
          ErrorObj := TJSONObject.Create;
          try
            ErrorObj.AddPair('error', 'Authentication error: ' + E.Message);
            Res.Status(500).Send<TJSONObject>(ErrorObj);
          except
            ErrorObj.Free;
            raise;
          end;
        end;
      end;
    end;
end;

end.
