unit AuthMiddleware;

interface

uses
  Horse,
  Horse.Core.RouterTree,
  Horse.Core.Route,
  Horse.Request,
  Horse.Response,
  Horse.Commons,
  Web.HTTPApp,
  System.SysUtils,
  System.JSON,
  System.Classes,
  System.Generics.Collections,
  Data.DB,
  JWTManager,
  UserModel;

type
  TAuthMiddleware = class
  private
    class function ExtractBearerToken(const AuthHeader: string): string;
    class function ValidateAndExtractClaims(const AToken: string; out Claims: TJWTClaims): Boolean;
    class function CheckRole(const RequiredRole, UserRole: TUserRole): Boolean;
    class procedure StoreClaimsInRequest(Req: THorseRequest; const Claims: TJWTClaims);
  public
    class function Middleware: THorseCallback;
    class function RoleMiddleware(RequiredRole: TUserRole): THorseCallback;
  end;

implementation

{ TAuthMiddleware }

class function TAuthMiddleware.ExtractBearerToken(const AuthHeader: string): string;
begin
  Result := '';
  if AuthHeader.StartsWith('Bearer ', True) then
    Result := AuthHeader.Substring(7);
end;

class function TAuthMiddleware.ValidateAndExtractClaims(const AToken: string; out Claims: TJWTClaims): Boolean;
begin
  Result := False;
  try
    Result := TJWTManager.ValidateToken(AToken, Claims);
  except
    on E: Exception do
      Result := False;
  end;
end;

class function TAuthMiddleware.CheckRole(const RequiredRole, UserRole: TUserRole): Boolean;
begin
  Result := (UserRole = RequiredRole) or (UserRole = urAdmin);
end;

class procedure TAuthMiddleware.StoreClaimsInRequest(Req: THorseRequest; const Claims: TJWTClaims);
begin

// For Horse framework
Req.Query.Dictionary.AddOrSetValue('user-id', Claims.UserId.ToString);
Req.Query.Dictionary.AddOrSetValue('user-role', IntToStr(Integer(Claims.Role)));
Req.Query.Dictionary.AddOrSetValue('username', Claims.Username);

end;

class function TAuthMiddleware.Middleware: THorseCallback;
begin
  Result := procedure(Req: THorseRequest; Res: THorseResponse; Next: TProc)
    var
      AuthHeader: string;
      Token: string;
      Path: string;
      Claims: TJWTClaims;
      ErrorObj: TJSONObject;
    begin
      try
        // Get the current path
        Path := Req.RawWebRequest.PathInfo.ToLower;

        // Skip authentication for public endpoints
        if (Path = '/auth/login') or (Path = '/auth/register') then
        begin
          Next;
          Exit;
        end;

        // Get Authorization header
        AuthHeader := Req.Headers['Authorization'];
        if AuthHeader.IsEmpty then
        begin
          ErrorObj := TJSONObject.Create;
          try
            ErrorObj.AddPair('error', 'Authorization header is required');
            Res.Status(401).Send<TJSONObject>(ErrorObj);
          except
            ErrorObj.Free;
            raise;
          end;
          Exit;
        end;

        // Extract token
        Token := ExtractBearerToken(AuthHeader);
        if Token.IsEmpty then
        begin
          ErrorObj := TJSONObject.Create;
          try
            ErrorObj.AddPair('error', 'Invalid authorization format');
            Res.Status(401).Send<TJSONObject>(ErrorObj);
          except
            ErrorObj.Free;
            raise;
          end;
          Exit;
        end;

        // Validate token and extract claims
        if not ValidateAndExtractClaims(Token, Claims) then
        begin
          ErrorObj := TJSONObject.Create;
          try
            ErrorObj.AddPair('error', 'Invalid or expired token');
            Res.Status(401).Send<TJSONObject>(ErrorObj);
          except
            ErrorObj.Free;
            raise;
          end;
          Exit;
        end;

        // Store claims in request
        StoreClaimsInRequest(Req, Claims);

        Next;
      except
        on E: Exception do
        begin
          ErrorObj := TJSONObject.Create;
          try
            ErrorObj.AddPair('error', 'Authentication error: ' + E.Message);
            Res.Status(500).Send<TJSONObject>(ErrorObj);
          except
            ErrorObj.Free;
            raise;
          end;
        end;
      end;
    end;
end;

class function TAuthMiddleware.RoleMiddleware(RequiredRole: TUserRole): THorseCallback;
begin
  Result := procedure(Req: THorseRequest; Res: THorseResponse; Next: TProc)
    var
      UserRole: TUserRole;
      ErrorObj: TJSONObject;
      RoleStr: string;
    begin
      try
        // Get user role from request data instead of headers
        RoleStr := Req.Query['user-role'];
        if RoleStr.IsEmpty then
        begin
          ErrorObj := TJSONObject.Create;
          try
            ErrorObj.AddPair('error', 'User role not found');
            Res.Status(403).Send<TJSONObject>(ErrorObj);
          except
            ErrorObj.Free;
            raise;
          end;
          Exit;
        end;

        UserRole := TUserRole(StrToIntDef(RoleStr, -1));
        if Integer(UserRole) < 0 then
        begin
          ErrorObj := TJSONObject.Create;
          try
            ErrorObj.AddPair('error', 'Invalid user role');
            Res.Status(403).Send<TJSONObject>(ErrorObj);
          except
            ErrorObj.Free;
            raise;
          end;
          Exit;
        end;

        if not CheckRole(RequiredRole, UserRole) then
        begin
          ErrorObj := TJSONObject.Create;
          try
            ErrorObj.AddPair('error', 'Insufficient permissions');
            Res.Status(403).Send<TJSONObject>(ErrorObj);
          except
            ErrorObj.Free;
            raise;
          end;
          Exit;
        end;

        Next;
      except
        on E: Exception do
        begin
          ErrorObj := TJSONObject.Create;
          try
            ErrorObj.AddPair('error', 'Role verification error: ' + E.Message);
            Res.Status(500).Send<TJSONObject>(ErrorObj);
          except
            ErrorObj.Free;
            raise;
          end;
        end;
      end;
    end;
end;

end.
